<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>v10.12 - 흔적 남기기</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&display=swap" rel="stylesheet">

<script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js"></script>
<style>
  body {
    background-color: #ffffff;
    height: 100vh;
    margin: 0;
    overflow: hidden;
    cursor: none;
    user-select: none;
  }
  #cursor-image, .trail-image, .placed-item {
    position: absolute;
    pointer-events: none;
    image-rendering: pixelated;
    transform-origin: center center;
    transition: transform 0.05s linear, top 0.05s linear, left 0.05s linear;
  }
  
  #cursor-image {
    z-index: 10002;
    transition: transform 0.05s linear, top 0s linear, left 0s linear, filter 0.4s ease-in-out;
  }

  .trail-image {
    z-index: 10001;
    opacity: 0;
    transition: opacity 0.2s ease-out, filter 0.4s ease-in-out;
    filter: brightness(0);
  }

  /* [수정됨] placed-item에 filter 전환 효과 추가 */
  .placed-item { 
    opacity: 1; 
    transition: filter 0.4s ease-in-out;
  }
  .placed-item.fading-out { animation: fadeOut 30s linear forwards; }
  @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
  
  /* .placed-item.placed-white 규칙은 이제 필요 없으므로 삭제되었습니다. */


  /* --- 🎨 핫바(Hotbar) CSS --- */
  
  #hotbar-border, #bottom-ui-container {
    transition: all 0.4s ease-in-out;
  }

  #hotbar-border {
    position: fixed;
    bottom: 10px;
    left: 10px;
    width: calc(100% - 260px);
    height: 180px;
    z-index: 9998;
    background-color: white;
    border-top: 3px solid black;
    border-bottom: 3px solid black;
    border-left: none;
    border-right: none;
    border-radius: 8px;
    box-sizing: border-box;
    pointer-events: none;
  }

  #bottom-ui-container {
    position: fixed;
    bottom: 10px;
    left: 10px;
    width: calc(100% - 260px);
    height: 180px;
    z-index: 9999;
    display: flex;
    align-items: center;
    padding: 0 20px;
    box-sizing: border-box;
  }

  body.webcam-is-fullscreen #hotbar-border {
    width: calc(100% - 20px);
    background-color: transparent;
    border-color: white;
  }
  body.webcam-is-fullscreen #bottom-ui-container {
    width: calc(100% - 20px);
  }


  #hotbar-container {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
  }

  #item-scroll-wrapper {
    width: 100%;
    overflow-x: auto;
    overflow-y: hidden;
    scrollbar-width: none;
    -ms-overflow-style: none;
    -webkit-mask-image: linear-gradient(to right, transparent, black 20px, black calc(100% - 20px), transparent);
    mask-image: linear-gradient(to right, transparent, black 20px, black calc(100% - 20px), transparent);
  }
  #item-scroll-wrapper::-webkit-scrollbar {
    display: none;
  }
  #item-bar {
    display: flex;
    flex-direction: row;
    align-items: center;
    padding: 50px 0;
    height: 100%;
    box-sizing: border-box;
  }
  .hotbar-item {
    width: 80px;
    height: 80px;
    margin: 0 2px;
    object-fit: contain;
    image-rendering: pixelated;
    transition: transform 0.2s ease-in-out, opacity 0.2s ease-in-out, filter 0.4s ease-in-out;
    flex-shrink: 0;
    transform-origin: center center;
    transform: var(--base-transform, 'none');
  }
  .hotbar-item:hover {
    transform: var(--base-transform, 'none') scale(1.1);
  }
  .hotbar-item.selected {
    transform: var(--base-transform, 'none') scale(1.35);
  }

  /* [수정됨] placed-item 규칙을 여기에 포함시켜 모든 아이템의 색상을 한 번에 제어 */
  body.webcam-is-fullscreen #cursor-image,
  body.webcam-is-fullscreen .trail-image,
  body.webcam-is-fullscreen .hotbar-item,
  body.webcam-is-fullscreen .placed-item {
    filter: brightness(0) invert(1);
  }


  #loading-message {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    font-family: sans-serif; font-size: 1.2em; padding: 20px;
    background-color: rgba(255, 255, 255, 0.8); border: 1px solid black;
    border-radius: 10px; z-index: 10002;
  }
  
  /* --- 📹 웹캠 관련 스타일 --- */
  #video-container, #video-border {
    transition: all 0.4s ease-in-out;
  }
  
  #video-container.fullscreen-webcam,
  #video-border.fullscreen-webcam {
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    border-radius: 0;
    z-index: 9990; 
  }
  
  #video-container.fullscreen-webcam video {
    object-fit: cover;
  }
  
  #video-container {
    position: fixed;
    top: calc(100vh - 180px - 10px);
    left: calc(100vw - 240px - 10px);
    width: 240px;
    height: 180px;
    border-radius: 8px;
    z-index: 10000;
    overflow: hidden;
    box-sizing: border-box;
  }
  
  #video-border {
    position: fixed;
    top: calc(100vh - 180px - 10px);
    left: calc(100vw - 240px - 10px);
    width: 240px;
    height: 180px;
    border-radius: 8px;
    border: 3px solid black;
    z-index: 10001;
    pointer-events: none;
    box-sizing: border-box;
  }
  
  body.webcam-is-fullscreen #video-border {
    border-color: white;
  }
  
  #webcam, #overlay-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transform: scaleX(-1);
  }
  
  .roughen-effect {
    filter: url(#roughen);
  }
  
  #item-label {
    position: absolute;
    display: flex;
    align-items: center;
    font-family: 'Nanum Gothic Coding', monospace;
    font-size: 14px;
    font-weight: bold;
    color: black;
    z-index: 10000;
    pointer-events: none;
    opacity: 0;
    transform: translateY(-50%);
    transition: opacity 0.3s ease, top 0.1s linear, left 0.1s linear, transform 0.1s linear, color 0.4s ease-in-out;
    visibility: hidden;
  }
  #item-label.visible {
    opacity: 1;
    visibility: visible;
  }
  #item-label-number {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
    background-color: black;
    color: white;
    border-radius: 4px;
    margin-right: 8px;
    font-size: 10px;
    transition: color 0.4s ease-in-out, background-color 0.4s ease-in-out;
  }

  body.webcam-is-fullscreen #item-label {
    color: white;
  }
  body.webcam-is-fullscreen #item-label-number {
    background-color: white;
    color: black;
  }
</style>
</head>
<body>

<svg style="position:absolute; height:0; width:0;">
  <filter id="roughen">
    <feTurbulence type="fractalNoise" baseFrequency="0.035" numOctaves="2" result="noise"/>
    <feDisplacementMap in="SourceGraphic" in2="noise" scale="6" />
  </filter>
</svg>

<img id="cursor-image">
<div id="loading-message">인식 모델을 로딩 중입니다...</div>

<div id="video-container">
  <video id="webcam" autoplay muted playsinline></video>
  <canvas id="overlay-canvas"></canvas>
</div>
<div id="video-border" class="roughen-effect"></div>

<div id="hotbar-border" class="roughen-effect"></div>
<div id="bottom-ui-container">
  <div id="hotbar-container">
    <div id="item-scroll-wrapper"><div id="item-bar"></div></div>
  </div>
</div>

<div id="item-label">
  <span id="item-label-number"></span>
  <span id="item-label-name"></span>
</div>


<script type="module">
  import { FaceLandmarker, HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js";

  const cursorImage = document.getElementById('cursor-image');
  const itemBar = document.getElementById('item-bar');
  const video = document.getElementById("webcam");
  const loadingMessage = document.getElementById("loading-message");
  const itemScrollWrapper = document.getElementById('item-scroll-wrapper');
  const canvas = document.getElementById("overlay-canvas");
  const canvasCtx = canvas.getContext("2d");
  const itemLabel = document.getElementById('item-label');
  const itemLabelNumber = document.getElementById('item-label-number');
  const itemLabelName = document.getElementById('item-label-name');

  const videoContainer = document.getElementById('video-container');
  const videoBorder = document.getElementById('video-border');

  videoContainer.addEventListener('dblclick', () => {
    document.body.classList.toggle('webcam-is-fullscreen');
    videoContainer.classList.toggle('fullscreen-webcam');
    videoBorder.classList.toggle('fullscreen-webcam');
    
    if (currentSelectedItem) {
      selectItem(currentSelectedItem);
    }
  });

  const defaultCursorUrl = "data:image/svg+xml,%3csvg id='Layer_1' fill='black' xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 32 32'%3e%3cpath d='M31.87,28.2c-.2-.57-1.35-1.91-2.01-1.83l-9.73-8.72c-.24.48-.43-.13-.64-.19-.2-.05-.32.21-.51.13l-1.57-1.42c.35-.07.52-.43.7-.72.43-.69.89-1.73,1.05-2.53.02-.08.11-.24-.02-.27l-.73,1.99c-.11-.26.22-.69.31-.99.19-.63.18-1.44.48-1.96l.07-1.35c.11-.21.11-.08.12.06.01.47-.08.91-.1,1.36,0,.08-.02.28.11.22.44-2.76-.39-5.71-2.21-7.88l-.49-.46c.39.51.72,1.05,1.01,1.61-1.11-1.69-2.78-2.93-4.69-3.59-.02,0-.04-.02-.05-.02C9.85.14,5.95.59,3.27,2.9,1.17,4.72.05,7.22.04,9.77c-.11,1.12,0,2.27.35,3.4,1.49,4.83,6.83,7.49,11.91,5.92,1.29-.4,2.44-1.03,3.42-1.83-1.2,1.06-2.66,1.76-4.42,2.1-2.76.53-5.44.14-7.77-1.48-.06,0-.03.09,0,.12.15.19.97.69,1.22.84,3.55,2.08,8.12,1.69,11.29-.94l.21.1,1.42,1.32.83-1.01-.86.77-1.54-1.5.84-1.02c.09-.09.17-.09.29-.05.09.03,1.34,1.17,1.4,1.26.08.12.06.19.05.32l.41-.29c.24.34.46.63.87.36l9.48,8.69-.22.36c.35-.28.63-.01.45.37l.41-.29s-.1.16-.05.27c.26.56,2.01.95,1.46,1.99-.33.64-1.13.51-1.71.7l-.08.36c-.48.31-1.54-.55-1.81-.97l1.06-1.33c-.38.08-1.06,1.36-1.37,1.25l-.14-.28,1.64-1.93-.28.16-9.36-8.8-1.41,1.28c-.2.09-.54-.53-.57-.5v.48l9.67,9.39c.06.64,1.19,1.58,1.77,1.77,1.8.59,3.59-1.15,2.97-2.92h0ZM1.23,12.9C-.11,8.54,2.55,3.84,7.17,2.42c4.62-1.42,9.46.97,10.81,5.34,1.35,4.37-1.32,9.07-5.94,10.49s-9.46-.97-10.81-5.34h0Z'/%3e%3c/svg%3e";
  
  const itemImageUrls = [
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0909-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0910-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0911-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0912-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0913-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0914-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0915-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0916-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0917-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0918-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0919-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0920-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0923-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0924-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0925-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0926-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0927-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0928-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0929-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/main/0920-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/89a2fee290f3b6f012cf6ec572343f998bf0f4fb/%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/89a2fee290f3b6f012cf6ec572343f998bf0f4fb/0921-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/89a2fee290f3b6f012cf6ec572343f998bf0f4fb/0922-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/89a2fee290f3b6f012cf6ec572343f998bf0f4fb/%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A83.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/89a2fee290f3b6f012cf6ec572343f998bf0f4fb/%E1%84%89%E1%85%A9%E1%86%AB%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/89a2fee290f3b6f012cf6ec572343f998bf0f4fb/%E1%84%89%E1%85%B5%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/89a2fee290f3b6f012cf6ec572343f998bf0f4fb/%E1%84%89%E1%85%B5%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A82.png',
    'https://raw.githubusercontent.com/youngwookim11/image-storage/89a2fee290f3b6f012cf6ec572343f998bf0f4fb/%E1%84%8C%E1%85%A1%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%80%E1%85%A5-%E1%84%8C%E1%85%A1%E1%84%80%E1%85%AE%E1%86%A8.png'
  ];
  
  const hotbarItemStyles = [
    { r: 80, sx: 1, sy: 1, tx: 30, ty: -25 }, { r: 90, sx:  1, sy: 1, tx: -30, ty: -25 }, { r: 90, sx: 1, sy: 1, tx: 30, ty: -25 },
    { r: 90, sx:  -1, sy: 1, tx: 30, ty: -25 }, { r: 90, sx: 1, sy: 1, tx: 30, ty: -25 }, { r: 90, sx:  -1, sy: 1, tx: 30, ty: -25 },
    { r: 90, sx: 1, sy: 1, tx: 30, ty: -25 }, { r: 90, sx:  -1, sy: 1, tx: 30, ty: -25 }, { r: 90, sx: -1, sy: 1, tx: -30, ty: -25 },
    { r: 90, sx:  -1, sy: 1, tx: 30, ty: -25 }, { r: 100, sx: -1, sy: 1, tx: -30, ty: -25 }, { r: 90, sx:  -1, sy: 1, tx: 30, ty: -25 },
    { r: 85, sx: 1, sy: 1, tx: 30, ty: -25 }, { r: 90, sx:  -1, sy: 1, tx: 30, ty: -25 }, { r: 90, sx: 1, sy: 1, tx: 30, ty: -25 },
    { r: 90, sx:  -1, sy: 1, tx: 30, ty: -25 }, { r: 90, sx: 1, sy: 1, tx: 30, ty: -25 }, { r: 90, sx:  -1, sy: 1, tx: 30, ty: -25 },
    { r: 90, sx: 1, sy: 1, tx: 30, ty: -25 },
    { r: 90, sx: -1, sy: 1, tx: 30, ty: -25 }, { r: 135, sx: -1, sy: 1, tx: 0, ty: -45 }, { r: 90, sx: -1, sy: 1, tx: 30, ty: -25 },
    { r: 90, sx: -1, sy: 1, tx: -30, ty: -25 }, { r: 90, sx: -1, sy: 1, tx: 30, ty: -25 }, { r: 90, sx: 1, sy: 1, tx: 20, ty: -35 },
    { r: 130, sx: 1, sy: 1, tx: -50, ty: -25 }, { r: 70, sx: 1, sy: 1, tx: 50, ty: -25 }, { r: 65, sx: 1, sy: 1, tx: -30, ty: -25 }
  ];

  const itemNames = [
    'Soil', 'Concrete', 'Asphalt', 'Soil', 'Wood', 'Wood', 'Wood', 'Asphalt', 'Asphalt', 
    'Wood', 'Asphalt', 'Concrete', 'Wood', 'Asphalt', 'Wood', 'Concrete', 'Wood', 
    'Wood', 'Wood', 'Soil', 'Soil', 'Soil', 'Asphalt', 'Soil', 'Asphalt', 'Soil', 'Soil', 'Concrete'
  ];

  const trailCount = 5;
  const trailImages = [];
  const positionHistory = [];
  let currentAngle = 0, isFlippedX = false, currentSize = 35;
  const minSize = 15, maxSize = 1000;
  let placedItemZIndex = 10003;
  let faceLandmarker, handLandmarker;
  let wasFistLastFrame = false, canClick = true;
  let frameCounter = 0;
  const detectionInterval = 2;
  let lastFaceResults = null, lastHandResults = null;
  let controlHandIndex = -1, controlState = "none";
  let isAdjustingSize = false;
  let lastSizeAdjustDistance = null;
  const sizeAdjustmentSensitivity = 500;
  let isSwiping = false, swipeStartX = 0;
  const swipeThreshold = 0.04;
  let currentSelectedItem = null;

  itemImageUrls.forEach((url, index) => {
    const itemImg = document.createElement('img');
    itemImg.src = url;
    itemImg.className = 'hotbar-item';
    itemBar.appendChild(itemImg);

    if (hotbarItemStyles[index]) {
      const style = hotbarItemStyles[index];
      const baseTransform = `rotate(${style.r}deg) scaleX(${style.sx}) scaleY(${style.sy}) translateY(${style.ty}px) translateX(${style.tx}px)`;
      itemImg.style.setProperty('--base-transform', baseTransform);
    }
  });
  
  itemScrollWrapper.addEventListener('wheel', (e) => {
    e.preventDefault();
    itemScrollWrapper.scrollLeft += e.deltaY + e.deltaX;
  });
  
  function applyCursorTransform() {
    let transformString = `translate(-50%, -50%) rotate(${currentAngle}deg)`;
    if (isFlippedX) { transformString += ` scaleX(-1)`; }
    cursorImage.style.transform = transformString;
  }

  function applySize(size) {
    currentSize = size;
    cursorImage.style.width = `${size}px`;
    cursorImage.style.height = `${size}px`;
    trailImages.forEach(trail => {
      trail.style.width = `${size}px`;
      trail.style.height = `${size}px`;
    });
  }

  function setCursor(cursorUrl) {
    cursorImage.src = cursorUrl;
    trailImages.forEach(trail => trail.src = cursorUrl);
  }

  function selectItem(itemElement) {
    const allItems = document.querySelectorAll('.hotbar-item');
    document.querySelector('.hotbar-item.selected')?.classList.remove('selected');
    
    if (itemElement) {
      const isFullscreen = document.body.classList.contains('webcam-is-fullscreen');
      const unselectedOpacity = isFullscreen ? '0.5' : '0.2';

      allItems.forEach(item => {
        item.style.opacity = (item === itemElement) ? '1' : unselectedOpacity;
      });

      currentSelectedItem = itemElement;
      itemElement.classList.add('selected');
      setCursor(itemElement.src);
      itemElement.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
      
      const index = Array.from(allItems).indexOf(itemElement);
      if (index !== -1 && itemNames[index]) {
          itemLabelNumber.textContent = index + 1;
          itemLabelName.textContent = itemNames[index];
          itemLabel.classList.add('visible');
      } else {
          itemLabel.classList.remove('visible');
      }

    } else {
      allItems.forEach(item => {
        item.style.opacity = '1';
      });

      currentSelectedItem = null;
      setCursor(defaultCursorUrl);
      itemLabel.classList.remove('visible');
    }
  }


  function selectNextItem() {
    const items = document.querySelectorAll('.hotbar-item');
    if (items.length === 0) return;
    const currentSelected = document.querySelector('.hotbar-item.selected');
    let nextIndex = 0;
    if (currentSelected) {
      nextIndex = (Array.from(items).indexOf(currentSelected) + 1) % items.length;
    }
    selectItem(items[nextIndex]);
  }

  function selectPreviousItem() {
    const items = document.querySelectorAll('.hotbar-item');
    if (items.length === 0) return;
    const currentSelected = document.querySelector('.hotbar-item.selected');
    let prevIndex = items.length - 1;
    if (currentSelected) {
      prevIndex = (Array.from(items).indexOf(currentSelected) - 1 + items.length) % items.length;
    }
    selectItem(items[prevIndex]);
  }

  function placeItemAt(x, y) {
    if (cursorImage.src === defaultCursorUrl) return;
    const placedItem = document.createElement('img');
    placedItem.src = cursorImage.src;
    placedItem.className = 'placed-item';
    
    // [수정됨] 색상을 동적으로 제어하므로 더 이상 별도 클래스를 추가할 필요가 없습니다.
    // if (document.body.classList.contains('webcam-is-fullscreen')) {
    //     placedItem.classList.add('placed-white');
    // }

    placedItem.style.left = `${x}px`;
    placedItem.style.top = `${y}px`;
    placedItem.style.width = `${currentSize}px`;
    placedItem.style.height = `${currentSize}px`;
    placedItem.style.transform = cursorImage.style.transform;
    placedItem.style.zIndex = placedItemZIndex++;
    document.body.appendChild(placedItem);
    setTimeout(() => placedItem.classList.add('fading-out'), 10);
    placedItem.addEventListener('animationend', () => placedItem.remove());
    isFlippedX = !isFlippedX;
    applyCursorTransform();
  }

  function drawTrail() {
    const rect = cursorImage.getBoundingClientRect();
    positionHistory.push({
      x: rect.left + rect.width / 2 + window.scrollX,
      y: rect.top + rect.height / 2 + window.scrollY,
      transform: cursorImage.style.transform
    });
    if (positionHistory.length > trailCount * 2) positionHistory.shift();
    trailImages.forEach((trail, index) => {
      const pos = positionHistory[Math.max(0, positionHistory.length - 1 - (index * 2))];
      if (pos) {
        trail.style.left = `${pos.x}px`;
        trail.style.top = `${pos.y}px`;
        trail.style.transform = pos.transform;
        trail.style.opacity = (trailImages.length - index) / trailImages.length * 0.4;
      }
    });
  }
  
  function updateLabelPosition() {
    if (currentSelectedItem) {
        const allItems = document.querySelectorAll('.hotbar-item');
        const index = Array.from(allItems).indexOf(currentSelectedItem);
        const rect = currentSelectedItem.getBoundingClientRect();

        if (index === 27) { 
            itemLabel.style.left = `${rect.right + -100}px`;
            itemLabel.style.top = `${rect.bottom + -40}px`;
            itemLabel.style.transform = 'translateY(0)';
        } else {
            itemLabel.style.left = `${rect.right + 1}px`;
            itemLabel.style.top = `${rect.top + rect.height / 2}px`;
            itemLabel.style.transform = 'translateY(-50%)';
        }
    }
  }

  window.addEventListener('click', (e) => {
    if (e.target.closest('#bottom-ui-container')) return;
    placeItemAt(e.pageX, e.pageY);
  });
  
  itemBar.addEventListener('click', (e) => {
    if (e.target.classList.contains('hotbar-item')) {
      if (e.target === currentSelectedItem) {
        selectItem(null); 
      } else {
        selectItem(e.target);
      }
    }
  });

  window.addEventListener('mousemove', (e) => {
    if (controlState === 'none') {
        cursorImage.style.left = `${e.pageX}px`;
        cursorImage.style.top = `${e.pageY}px`;
    }
  });

  async function setupMediaPipe() {
    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
    faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
      baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`, delegate: "GPU" },
      runningMode: "VIDEO", numFaces: 1,
    });
    handLandmarker = await HandLandmarker.createFromOptions(vision, {
      baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
      runningMode: "VIDEO", numHands: 2,
    });
    loadingMessage.style.display = 'none';
    enableCam();
  }

  function enableCam() {
    if (!faceLandmarker || !handLandmarker) return;
    navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
      video.srcObject = stream;
      video.addEventListener("loadeddata", () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        requestAnimationFrame(predictWebcam);
      });
    }).catch(err => {
        console.error("웹캠 접근 오류:", err);
        loadingMessage.innerText = "웹캠에 접근할 수 없습니다. 권한을 확인해주세요.";
        loadingMessage.style.display = 'block';
    });
  }

  function getDistance(p1, p2) {
      if (!p1 || !p2) return 0;
      return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
  }

  function detectHandGesture(landmarks) {
      try {
          const thumbTip = landmarks[4], thumbPip = landmarks[2];
          const indexTip = landmarks[8], indexPip = landmarks[6];
          const middleTip = landmarks[12], middlePip = landmarks[10];
          const ringTip = landmarks[16], ringPip = landmarks[14];
          const pinkyTip = landmarks[20], pinkyPip = landmarks[18];
          const isThumbExtended = thumbTip.y < thumbPip.y;
          const isIndexExtended = indexTip.y < indexPip.y;
          const isMiddleExtended = middleTip.y < middlePip.y;
          const isRingFolded = ringTip.y > ringPip.y;
          const isPinkyFolded = pinkyTip.y > pinkyPip.y;
          const palmWidth = getDistance(landmarks[5], landmarks[17]);
          const isThumbOut = getDistance(thumbTip, indexPip) > palmWidth * 0.7;

          if (isThumbExtended && !isIndexExtended && !isMiddleExtended && isRingFolded && isPinkyFolded && isThumbOut) return "ThumbsUp";
          if (isThumbExtended && isIndexExtended && !isMiddleExtended && isRingFolded && isPinkyFolded) return "Size Adjust";
          if (isIndexExtended && isMiddleExtended && isRingFolded && isPinkyFolded) return "Pointing";
          if (!isIndexExtended && !isMiddleExtended && isRingFolded && isPinkyFolded) return "Click";
          return "None";
      } catch (e) {
          return "None";
      }
  }

  async function predictWebcam() {
    let startTimeMs = performance.now();
    if (video.readyState < 2) {
      requestAnimationFrame(predictWebcam);
      return;
    }
    canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
    if (frameCounter % detectionInterval === 0) {
      lastFaceResults = faceLandmarker.detectForVideo(video, startTimeMs);
      lastHandResults = handLandmarker.detectForVideo(video, startTimeMs);
    }
    frameCounter++;

    if (lastFaceResults?.faceLandmarks?.length > 0) {
      const landmarks = lastFaceResults.faceLandmarks[0];
      const p1 = landmarks[1], p2 = landmarks[6];
      currentAngle = (Math.atan2(p1.y - p2.y, p1.x - p2.x) * (180 / Math.PI) - 90) * 4;
      applyCursorTransform();

      let minX = 1, maxX = 0, minY = 1, maxY = 0;
      for (const point of landmarks) {
          minX = Math.min(minX, point.x); maxX = Math.max(maxX, point.x);
          minY = Math.min(minY, point.y); maxY = Math.max(maxY, point.y);
      }
      canvasCtx.strokeStyle = "red";
      canvasCtx.lineWidth = 4;
      canvasCtx.strokeRect(minX * canvas.width, minY * canvas.height, (maxX - minX) * canvas.width, (maxY - minY) * canvas.height);
    }

    const detectedHands = lastHandResults?.landmarks || [];
    const gestures = detectedHands.map(detectHandGesture);
    let isFist = false;
    
    const resetControl = () => {
        controlState = "none";
        controlHandIndex = -1;
        isAdjustingSize = false;
        isSwiping = false;
        lastSizeAdjustDistance = null;
    };

    if (controlState === "none") {
        const pointingHandIdx = gestures.findIndex(g => g === "Pointing");
        if (pointingHandIdx !== -1) {
            controlHandIndex = pointingHandIdx;
            controlState = "pointing";
        }
    } else {
        if (controlHandIndex >= detectedHands.length) {
            resetControl();
        } else {
            const currentGesture = gestures[controlHandIndex];
            const controlLandmarks = detectedHands[controlHandIndex];

            if (currentGesture === "ThumbsUp") {
                controlState = "swiping";
                const currentX = controlLandmarks[4].x;
                if (!isSwiping) {
                    isSwiping = true;
                    swipeStartX = currentX;
                } else {
                    const deltaX = currentX - swipeStartX;
                    if (deltaX < -swipeThreshold) {
                        selectNextItem(); isSwiping = false;
                    } else if (deltaX > swipeThreshold) {
                        selectPreviousItem(); isSwiping = false;
                    }
                }
            } else if (currentGesture === "Size Adjust") {
                controlState = "sizing";
                isAdjustingSize = true;
                const currentDistance = getDistance(controlLandmarks[4], controlLandmarks[8]);
                
                if (lastSizeAdjustDistance !== null) {
                    const distanceDelta = currentDistance - lastSizeAdjustDistance;
                    let newSize = currentSize + (distanceDelta * sizeAdjustmentSensitivity);
                    applySize(Math.max(minSize, Math.min(maxSize, newSize)));
                }
                
                lastSizeAdjustDistance = currentDistance;
            } else if (currentGesture === "Pointing") {
                controlState = "pointing";
                isAdjustingSize = false;
                lastSizeAdjustDistance = null;
                const targetX = (1 - (controlLandmarks[8].x + controlLandmarks[12].x) / 2) * window.innerWidth;
                const targetY = ((controlLandmarks[8].y + controlLandmarks[12].y) / 2) * window.innerHeight;
                cursorImage.style.left = `${targetX}px`;
                cursorImage.style.top = `${targetY}px`;
            } else {
                resetControl();
            }
            const actionHandIndex = 1 - controlHandIndex;
            if (actionHandIndex < detectedHands.length && gestures[actionHandIndex] === "Click") {
                isFist = true;
            }
        }
    }

    if (isFist && !wasFistLastFrame && canClick) {
        const cursorRect = cursorImage.getBoundingClientRect();
        placeItemAt(cursorRect.left + cursorRect.width / 2, cursorRect.top + cursorRect.height / 2);
        canClick = false;
        setTimeout(() => { canClick = true; }, 1000);
    }
    wasFistLastFrame = isFist;
    if (detectedHands.length === 0) resetControl();
    
    detectedHands.forEach((landmarks, i) => {
        let minX = 1, maxX = 0, minY = 1, maxY = 0;
        landmarks.forEach(point => {
            minX = Math.min(minX, point.x); maxX = Math.max(maxX, point.x);
            minY = Math.min(minY, point.y); maxY = Math.max(maxY, point.y);
        });
        const boxX = minX * canvas.width, boxY = minY * canvas.height;
        const boxWidth = (maxX - minX) * canvas.width, boxHeight = (maxY - minY) * canvas.height;

        let roleText = gestures[i], color = "blue";
        if (i === controlHandIndex) {
            roleText = "Control: " + gestures[i];
            if (isAdjustingSize) roleText = "Control: Sizing";
            if (isSwiping) roleText = "Control: Swiping";
            color = "green";
        } else if (controlHandIndex !== -1) {
            let actionText = "Action: " + gestures[i];
            if(gestures[i] === 'Click') actionText = "Action: Click!";
            roleText = actionText;
            color = "orange";
        }

        canvasCtx.strokeStyle = color;
        canvasCtx.lineWidth = 4;
        canvasCtx.strokeRect(boxX, boxY, boxWidth, boxHeight);

        const textBoxHeight = 30;
        canvasCtx.fillStyle = color;
        canvasCtx.fillRect(boxX, boxY + boxHeight, boxWidth, textBoxHeight);
        canvasCtx.save();
        canvasCtx.scale(-1, 1);
        canvasCtx.fillStyle = "white";
        canvasCtx.font = "16px sans-serif";
        canvasCtx.textAlign = "center";
        canvasCtx.fillText(roleText, -(boxX + boxWidth / 2), boxY + boxHeight + (textBoxHeight / 2) + 6);
        canvasCtx.restore();
    });

    drawTrail();
    updateLabelPosition();
    requestAnimationFrame(predictWebcam);
  }

  for (let i = 0; i < trailCount; i++) {
    const trailImg = document.createElement('img');
    trailImg.className = 'trail-image';
    document.body.appendChild(trailImg);
    trailImages.push(trailImg);
  }

  setupMediaPipe();
  selectItem(null);
  applySize(currentSize);
  applyCursorTransform();
</script>

</body>
</html>
